#include <Wire.h>
#include <Adafruit_SI5351.h>
Adafruit_SI5351 clockgen = Adafruit_SI5351();

#define SPISPEED 1000000
#define _SPI_CLOCK_DIVIDER 16000000/SPISPEED

const int N = 2048/8;
/*byte data[]={
   0xff,0x67,0xa6,0xa5,0xa3,0x53,0x2c,0x4a,0x10,0x2a,0x10,0xd5,0x77,0x73,0xd2,0xd0,0x81,0xfc,0xcb,0xec,
   0xe1,0xfc,0x34,0x8b,0x47,0x59,0x97,0xd8,0x6b,0x13,0x87,0xf2,0x7b,0xc6,0xf0,0x81,0xa9,0x16,0x71,0x7d,
   0x62,0xfa,0x90,0x81,0x56,0x71,0xd7,0xd8,0xc1,0xa9,0xbc,0xcb,0x46,0x5b,0xc7,0x0d,0xb6,0xda,0x6e,0x1b,
   0xc7,0xa7,0x0c,0xe1,0x57,0x26,0x5a,0x90,0x80,0xfe,0x9b,0x39,0x3c,0x35,0xdd,0x62,0xfb,0x38,0x6b,0xb8,
   0x95,0x23,0xac,0x1f,0x99,0xc2,0xfb,0x39,0xc3,0x52,0x7b,0xc7,0x58,0x6b,0x47,0xf2,0x85,0x09,0xbc,0xca,
   0xee,0xb1,0x29,0xe9,0x42,0xae,0xb0,0x2b,0xb9,0x97,0x73,0x79,0xc2,0x50,0x2b,0x12,0x85,0xa2,0xae,0x1b,
   0x39,0x68,0x40,0xaa,0x10,0x81,0x02,0x04,0xa0,0xaa,0xbb,0x93,0xd3,0xd3,0x79,0xc3,0xf8,0xc1,0xfc,0x61,
   0x56,0xda,0xc5,0x09,0x16,0x70,0xd5,0x88,0x14,0x74,0x75,0x22,0xaf,0xe7,0xa6,0xf1,0xd6,0x24,0x5e,0x30,
   0x2a,0x45,0x08,0xea,0xef,0x4c,0x1e,0x9a,0x3a,0xc4,0x0a,0xee,0x4f,0xe6,0xa5,0x09,0xe9,0x17,0x73,0x2d,
   0xb7,0x27,0x59,0x68,0xbf,0xcd,0xb6,0x24,0xa1,0x57,0x8c,0xe0,0xab,0xb9,0xc3,0x06,0x0e,0xb0,0x2a,0x11,
   0x7d,0x9d,0x9d,0x36,0x24,0xf5,0x22,0xfb,0x92,0xd1,0x83,0xac,0x1e,0x31,0x28,0x15,0xdd,0x37,0x26,0xa5,
   0xf7,0x26,0x5b,0x38,0x6a,0x10,0x7f,0xcd,0x48,0xeb,0xed,0x1c,0xcb,0x47,0xf3,0x2d,0xe3,0x52,0x2e,0x1a,
   0xc5,0xf7,0xd9,0x3c,0x9e,0xcf,0xb3,0x2c,0xe1,0x02,0xfb,0xc7,0x0c,0x1e,0x30,0x00};
*/
byte data[]={
 0xff,0xe6,0x65,0xa5,0xc5,0xca,0x34,0x52,0x08,0x54,0x08,0xab,0xee,0xce,0x4b,0x0b,0x81,0x3f,0xd3,0x37,
   0x87,0x3f,0x2c,0xd1,0xe2,0x9a,0xe9,0x1b,0xd6,0xc8,0xe1,0x4f,0xde,0x63,0x0f,0x81,0x95,0x68,0x8e,0xbe,
   0x46,0x5f,0x09,0x81,0x6a,0x8e,0xeb,0x1b,0x83,0x95,0x3d,0xd3,0x62,0xda,0xe3,0xb0,0x6d,0x5b,0x76,0xd8,
   0xe3,0xe5,0x30,0x87,0xea,0x64,0x5a,0x09,0x01,0x7f,0xd9,0x9c,0x3c,0xac,0xbb,0x46,0xdf,0x1c,0xd6,0x1d,
   0xa9,0xc4,0x35,0xf8,0x99,0x43,0xdf,0x9c,0xc3,0x4a,0xde,0xe3,0x1a,0xd6,0xe2,0x4f,0xa1,0x90,0x3d,0x53,
   0x77,0x8d,0x94,0x97,0x42,0x75,0x0d,0xd4,0x9d,0xe9,0xce,0x9e,0x43,0x0a,0xd4,0x48,0xa1,0x45,0x75,0xd8,
   0x9c,0x16,0x02,0x55,0x08,0x81,0x40,0x20,0x05,0x55,0xdd,0xc9,0xcb,0xcb,0x9e,0xc3,0x1f,0x83,0x3f,0x86,
   0x6a,0x5b,0xa3,0x90,0x68,0x0e,0xab,0x11,0x28,0x2e,0xae,0x44,0xf5,0xe7,0x65,0x8f,0x6b,0x24,0x7a,0x0c,
   0x54,0xa2,0x10,0x57,0xf7,0x32,0x78,0x59,0x5c,0x23,0x50,0x77,0xf2,0x67,0xa5,0x90,0x97,0xe8,0xce,0xb4,
   0xed,0xe4,0x9a,0x16,0xfd,0xb3,0x6d,0x24,0x85,0xea,0x31,0x07,0xd5,0x9d,0xc3,0x60,0x70,0x0d,0x54,0x88,
   0xbe,0xb9,0xb9,0x6c,0x24,0xaf,0x44,0xdf,0x49,0x8b,0xc1,0x35,0x78,0x8c,0x14,0xa8,0xbb,0xec,0x64,0xa5,
   0xef,0x64,0xda,0x1c,0x56,0x08,0xfe,0xb3,0x12,0xd7,0xb7,0x38,0xd3,0xe2,0xcf,0xb4,0xc7,0x4a,0x74,0x58,
   0xa3,0xef,0x9b,0x3c,0x79,0xf3,0xcd,0x34,0x87,0x40,0xdf,0xe3,0x30,0x78,0x0c,0x00};
  static void writeBytes(register uint8_t *data, int len) {
    uint8_t *end = data+len;
    while(data!=end) {
      UCSR0A = _BV(TXC0);              // Clear the Transmit complete flag, all other bits should be written 0.
      UDR0=(*data++);
      while(!(UCSR0A & (1<<UDRE0)));
    }
  }

void setup() {
//  Serial.begin(9600);
//  Serial.println("Si5351 Clockgen Test"); Serial.println("");
  
  /* Initialise the sensor */
  if (clockgen.begin() != ERROR_NONE)
  {
    /* There was a problem detecting the IC ... check your connections */
//    Serial.print("Ooops, no Si5351 detected ... Check your wiring or I2C ADDR!");
    while(1);
  }
//  Serial.println("OK!");
//  pinMode(2, OUTPUT);  
//  Serial.println("Set Output #0 to 13.553115MHz");  
  // 25MHz * (25+6/25)= 631 MHz, then 631 MHz / 4 = 157.75 MHz : x9 = 1419.75 MHz
  clockgen.setupPLL(SI5351_PLL_A, 25, 6, 25);
//  clockgen.setupMultisynth(0, SI5351_PLL_A, 45, 1, 2);
//  Serial.println("Set Output #0 to 112.5MHz");
// clockgen.setupPLLInt(SI5351_PLL_A, 36);
 clockgen.setupMultisynthInt(2, SI5351_PLL_A, SI5351_MULTISYNTH_DIV_4);
  clockgen.enableOutputs(true);

  UBRR0 = 0x0000;
  UCSR0C = (1<<UMSEL01)|(1<<UMSEL00)|(0<<UCPOL0);
  UCSR0B = (1<<TXEN0);
  UBRR0 = (_SPI_CLOCK_DIVIDER/2)-1;

  pinMode(13, OUTPUT);     
//  pinMode(1, OUTPUT);     
}

/*void TXpulse(){
  pinMode(1, INPUT);     

  byte bUCSR0C=UCSR0C;
  byte bUCSR0B=UCSR0B;
  
  UBRR0 = 0x0000;
  UCSR0C = (1<<UMSEL01)|(1<<UMSEL00)|(0<<UCPOL0);
  UCSR0B = (1<<TXEN0);
  UBRR0 = (_SPI_CLOCK_DIVIDER/2)-1;

  writeBytes(data, N);

 UCSR0C=bUCSR0C;
 UCSR0B = bUCSR0B;
 pinMode(1, OUTPUT);     
}*/

bool LEDstat;
unsigned long oldtime=0,newtime;

void loop() {
//  setup();
//  unsigned long t1;

//  t1 = micros();
//  TXpulse();
//  t1 = micros() -t1;
//  delay(500);
//  Serial.begin(9600);
//  Serial.println(t1);
//   digitalWrite(1, HIGH); 
   newtime=millis();
   if (newtime-oldtime<20000) return;
   oldtime=newtime;

   LEDstat=HIGH;
   for (int count=0;count<10;count++) {
     writeBytes(data, N);
     digitalWrite(13, LEDstat);   // set the LED on
     LEDstat=!LEDstat;   
     delay(1000);
   }
  digitalWrite(13, LOW);   // set the LED on
}
